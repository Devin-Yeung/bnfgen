use crate::token::{Token, LexicalError};
use crate::span::Span;
use crate::grammar::{RawGrammar, Rule, Alternative, Symbol, SymbolKind, WeightedProduction};
use std::rc::Rc;

// grammar start
grammar;

// bridge the lexer
extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "(" => Token::LParen,
    ")" => Token::RParen,
    "|" => Token::Or,
    "," => Token::Comma,
    "::=" => Token::Def,
    ";" => Token::Semi,
    "re" => Token::Re,
    "str" => Token::Str(<String>),
    "nonterminal" => Token::NonTerminal(<String>),
    "int" => Token::Int(<usize>),
  }
}

pub RawGrammar: RawGrammar = {
    <_l: @L> <rules: Rule*> <_r: @R> => {
        RawGrammar {
            rules,
        }
    }
};

Rule: Rule = {
    <l: @L> <name: "nonterminal"> "::=" <production: Alternatives> ";" <r: @R> => {
        Rule {
            name,
            production: WeightedProduction {
                production,
            },
            span: Span::new(l, r),
        }
    }
};

Or<T>: Vec<T> = {
    <mut v:(<T> "|")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Alternatives = Or<Alternative>;

Alternative: Alternative = {
    <weight: "int"?> <symbols: Symbol+> => {
        Alternative {
            weight: weight.unwrap_or(1),
            symbols,
        }
    }
};

Symbol: Symbol = {
    <l: @L> <t: "str"> <r: @R> => {
        Symbol {
            kind: SymbolKind::Terminal(Rc::new(t)),
            span: Span::new(l, r),
        }
    },
    <l: @L> <nt: "nonterminal"> <r: @R> => {
        Symbol {
            kind: SymbolKind::NonTerminal(Rc::new(nt)),
            span: Span::new(l, r),
        }
    },
    <l: @L> "re" "(" <re: "str"> ")" <r: @R> => {
        Symbol {
            kind: SymbolKind::Regex(Rc::new(re)),
            span: Span::new(l, r),
        }
    },
    <l: @L> <s: Symbol> "{" <lo: "int"> "," <hi: "int"?> "}" <r: @R>  => {
        Symbol {
            kind: SymbolKind::Repeat {
                symbol: Box::new(s.kind), 
                min: lo, 
                max: hi,
            },
            span: Span::new(l, r),
        }
    },
    // exact match
    <l: @L> <s: Symbol> "{" <cnt: "int"> "}" <r: @R>  => {
        Symbol {
            kind: SymbolKind::Repeat {
                symbol: Box::new(s.kind), 
                min: cnt, 
                max: Some(cnt),
            },
            span: Span::new(l, r),
        }
    }
};
