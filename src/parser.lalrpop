use crate::token::{Token, LexicalError};
use crate::grammar::{RawGrammar, Rule, Alternative, Symbol, SymbolKind, WeightedProduction};
use std::rc::Rc;

// grammar start
grammar;

// bridge the lexer
extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "(" => Token::LParen,
    ")" => Token::RParen,
    "|" => Token::Or,
    "," => Token::Comma,
    "::=" => Token::Def,
    ";" => Token::Semi,
    "re" => Token::Re,
    "str" => Token::Str(<String>),
    "nonterminal" => Token::NonTerminal(<String>),
    "int" => Token::Int(<usize>),
  }
}

pub RawGrammar: RawGrammar = {
    <_l: @L> <rules: Rule*> <_r: @R> => {
        RawGrammar {
            rules,
        }
    }
};

Rule: Rule = {
    <name: "nonterminal"> "::=" <production: Alternatives> ";" => {
        Rule {
            name,
            production: WeightedProduction {
                production,
            }
        }
    }
};

Or<T>: Vec<T> = {
    <mut v:(<T> "|")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Alternatives = Or<Alternative>;

Alternative: Alternative = {
    <weight: "int"?> <symbols: Symbol+> => {
        Alternative {
            weight: weight.unwrap_or(1),
            symbols,
        }
    }
};

Symbol: Symbol = {
    "str" => {
        Symbol {
            kind: SymbolKind::Terminal(Rc::new(<>))
        }
    },
    "nonterminal" => {
        Symbol {
            kind: SymbolKind::NonTerminal(Rc::new(<>))
        }
    },
    "re" "(" <re: "str"> ")" => {
        Symbol {
            kind: SymbolKind::Regex(Rc::new(re))
        }
    }
};
